<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÜîÎ¶¨ÌÖåÏñ¥</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --text-color: #ffffff;
            --primary-font: 'Noto Sans KR', sans-serif;

            /* Dynamic Card Size Configuration */
            --app-max-width: 600px;
            /* Cap width for desktop */
            --app-padding: 12px;
            /* Base width is either the viewport width OR the max width */
            --base-width: min(100vw, var(--app-max-width));

            /* Card Size Calculation based on 4 columns */
            --card-width: calc((var(--base-width) - 32px) / 4 - 6px);
            --card-height: calc(((var(--base-width) - 32px) / 4 - 6px) * 1.4);
            --gap: 6px;

            /* Dynamic Visual Scaling */
            --card-radius: calc(var(--card-width) * 0.1);
            /* 10% of width */
            --card-font-size: calc(var(--card-width) * 0.25);
            /* Increased from 0.2 to 0.25 (25%) */
            --card-emoji-size: calc(var(--card-width) * 0.6);
            /* Increased from 0.5 to 0.6 (60%) */

            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-border-subtle: rgba(255, 255, 255, 0.15);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--primary-font);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            overflow: hidden;
            /* Prevent body scroll */
        }

        /* MAIN APP CONTAINER - Fixed Vertical Grid */
        #app {
            display: grid;
            grid-template-areas:
                "header controls"
                "sorting sorting"
                "tableau tableau";
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto 1fr;
            /* Header, Sorting, Tableau (Flexible) */
            gap: 16px;
            padding: var(--app-padding);

            width: 100%;
            max-width: var(--app-max-width);
            /* Enforce mobile width on desktop */
            height: 100vh;
            height: 100dvh;

            margin: 0 auto;
            /* Center on desktop */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            /* Shadow for desktop aesthetics */
            background: #131323;
            /* Slightly darker background for the "device" area */
        }

        /* --- 1. HEADER (Left Top) --- */
        .left-panel {
            grid-area: header;
            display: flex;
            flex-direction: column;
            width: 100%;
            align-items: flex-start;
            padding: 0;
        }

        .difficulty-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            width: 100%;
            margin-bottom: 8px;
        }

        .diff-btn {
            border: none;
            border-radius: 4px;
            padding: 4px;
            height: 28px;
            font-size: 0.7rem;
            cursor: pointer;
            color: white;
            opacity: 0.6;
            transition: all 0.2s;
            font-weight: bold;
        }

        .diff-btn.active {
            opacity: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
        }

        .diff-easy {
            background-color: #4CAF50;
        }

        .diff-normal {
            background-color: #2196F3;
        }

        .diff-hard {
            background-color: #FF9800;
        }

        .diff-extreme {
            background-color: #E91E63;
        }

        .left-panel>div:last-child {
            display: flex;
            width: 100%;
            gap: 10px;
        }

        .restart-btn {
            background: rgba(255, 82, 82, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--card-radius);
            color: white;
            font-weight: 700;
            cursor: pointer;
            flex: 1;
            /* Grow to fill space */
            height: 44px;
            font-size: 0.9rem;
        }

        .restart-btn:active {
            background: rgba(255, 82, 82, 1);
            transform: scale(0.98);
        }

        .turn-counter {
            display: flex;
            flex-direction: row;
            /* Horizontal on mobile layout */
            justify-content: center;
            align-items: center;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-subtle);
            border-radius: var(--card-radius);
            padding: 0 10px;
            height: 44px;
            gap: 8px;
            min-width: 80px;
        }

        .turn-counter .label {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .turn-counter .value {
            font-size: 1.2rem;
            font-weight: 800;
        }

        /* --- 2. CONTROLS (Right Top) --- */
        .right-panel {
            grid-area: controls;
            display: flex;
            justify-content: flex-end;
            align-items: flex-end;
            /* Align to bottom of the header row */
            width: 100%;
            padding: 0;
            height: 100%;
            /* Fill height to align with left panel */
        }

        .deck-area {
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
        }

        /* --- 3. SORTING AREA (Row 2) --- */
        .center-board {
            display: contents;
            /* Unwrap container to use grid areas directly */
        }

        .sorting-area {
            grid-area: sorting;
            display: grid;
            grid-template-columns: repeat(4, var(--card-width));
            gap: var(--gap);
            justify-content: center;
            width: 100%;
            padding-top: 45px;
            /* Updated padding */
            padding-bottom: 10px;
            border-bottom: 1px solid var(--glass-border);
            margin-bottom: 5px;
        }

        /* --- 4. TABLEAU AREA (Row 3, Main) --- */
        .tableau-area {
            grid-area: tableau;
            display: grid;
            grid-template-columns: repeat(4, var(--card-width));
            gap: var(--gap);
            justify-content: center;
            width: 100%;

            overflow-y: auto;
            /* Internal scrolling for tableau */
            padding-top: 10px;
            min-height: 0;
            /* Crucial for grid scroll */
        }

        .tableau-column {
            display: flex;
            flex-direction: column;
            width: var(--card-width);
            min-height: 200px;
            /* Drop target size */
            position: relative;
        }

        /* --- COMMON SLOTS & CARDS --- */
        .slot {
            width: var(--card-width);
            height: var(--card-height);
            border: 1px dashed var(--glass-border);
            border-radius: var(--card-radius);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.02);
        }

        .slot-base {
            width: 100%;
            height: var(--card-height);
            border-radius: var(--card-radius);
            background: rgba(255, 255, 255, 0.05);
            /* Faint background for visibility guide */
            border: 2px dashed rgba(255, 255, 255, 0.1);
            opacity: 0.5;
            /* Ensure it occupies space */
        }

        /* Hide heavy bases in this clean layout */

        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--card-radius);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            position: absolute;
            transition: top 0.15s ease, transform 0.15s ease;

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: white;
            z-index: 10;

            padding: 4px;
            font-size: var(--card-font-size);
            border-width: 1px;
        }

        .card.key-card {
            border: 2px solid #ff5252;
            color: #d32f2f;
            font-weight: 900;
            justify-content: space-between;
            padding-top: 8px;
            padding-bottom: 4px;
        }

        .card.sub-card {
            border: 1px solid #448aff;
            color: #333;
            font-weight: 700;
        }

        .card.stacked-view {
            justify-content: flex-start !important;
            padding-top: 4px;
        }

        .key-counter {
            font-size: 0.6rem;
            opacity: 0.9;
            align-self: flex-end;
            width: 100%;
            text-align: right;
            padding-right: 2px;
        }

        .card .label {
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.1;
        }

        .card.back {
            background-color: #E0D7D0;
            border: 1px solid #BCAAA4;
        }

        .card.back .rabbit-icon {
            width: 70%;
            height: 70%;
            background-color: #5D4037;
            -webkit-mask: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12,2C12,2 8,5 8,10C8,11.5 8.5,13 9,14C7,14 4,16 4,19C4,21 6,22 12,22C18,22 20,21 20,19C20,16 17,14 15,14C15.5,13 16,11.5 16,10C16,5 12,2 12,2M12,5C12.8,5 13.5,7 13.8,9C13.2,8.8 12.6,8.8 12,8.8C11.4,8.8 10.8,8.8 10.2,9C10.5,7 11.2,5 12,5Z"/></svg>') no-repeat center;
            -webkit-mask-size: contain;
            mask: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12,2C12,2 8,5 8,10C8,11.5 8.5,13 9,14C7,14 4,16 4,19C4,21 6,22 12,22C18,22 20,21 20,19C20,16 17,14 15,14C15.5,13 16,11.5 16,10C16,5 12,2 12,2M12,5C12.8,5 13.5,7 13.8,9C13.2,8.8 12.6,8.8 12,8.8C11.4,8.8 10.8,8.8 10.2,9C10.5,7 11.2,5 12,5Z"/></svg>') no-repeat center;
            mask-size: contain;
        }

        /* Sorting Slot Labels - Restore visibility */
        .sorting-slot::before {
            content: attr(data-label);
            position: absolute;
            top: -40px;
            /* Moved further up */
            left: 50%;
            transform: translateX(-50%);
            width: 150%;
            /* Allow wider text */
            text-align: center;
            font-size: 0.8rem;
            color: #ffffff;
            /* FIX: White text for dark background */
            white-space: pre-wrap;
            /* Allow newlines */
            line-height: 1.2;
            /* Slightly increased line height */
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            /* FIX: Dark shadow for contrast */
            pointer-events: none;
            display: block;
            /* Ensure visibility */
        }
    </style>

</head>

<body>
    <div id="app">
        <!-- 1. LEFT PANEL: Turn Counter -->
        <div class="left-panel">
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <!-- Difficulty Selector -->
                <div class="difficulty-selector" id="diff-selector"><button class="diff-btn diff-easy"
                        data-diff="EASY">Ïâ¨ÏõÄ</button><button class="diff-btn diff-normal active"
                        data-diff="NORMAL">Î≥¥ÌÜµ</button><button class="diff-btn diff-hard"
                        data-diff="HARD">Ïñ¥Î†§ÏõÄ</button><button class="diff-btn diff-extreme"
                        data-diff="EXTREME">Í∑πÏïÖ</button></div>
                <div style="display: flex; flex-direction: row; gap: 10px; align-items: center;"><button
                        id="restart-btn" class="restart-btn">Ïû¨ÏãúÏûë</button>
                    <div class="turn-counter"><span class="label">ÎÇ®ÏùÄ ÌÑ¥</span><span id="turns-value"
                            class="value">0</span></div>
                </div>
            </div>
        </div>
        <!-- 2. CENTER BOARD: Sorting & Tableau -->
        <div class="center-board">
            <!-- Row 1: Sorting Slots -->
            <div id="sorting-area" class="sorting-area">
                <!-- Sorting Slots generated by JS -->
            </div>
            <!-- Row 2: Tableau Columns -->
            <div id="tableau-area" class="tableau-area">
                <!-- Deployment Slots -->
            </div>
        </div>
        <!-- 3. RIGHT PANEL: Deck & Graveyard -->
        <div class="right-panel">
            <div class="deck-area">
                <!-- Discard Pile (Open) -->
                <div id="graveyard" class="slot" style="border-style: solid; border-color: rgba(255,255,255,0.1);">
                    <!-- Face Up Cards go here -->
                </div>
                <!-- Draw Pile (Hidden) -->
                <div id="deck-pile" class="slot" style="border: none;">
                    <!-- Face Down Cards go here -->
                </div>
            </div>
        </div>
    </div>
    <script src="js/categories.js"></script>
    <script> // --- CONSTANTS ---
        // CATEGORIES_POOL is now loaded from js/categories.js

        const CARD_TYPES = {
            KEY: 'KEY',
            SUB: 'SUB'
        }

            ;

        const GAME_CONFIG = {
            // Turns will be calculated dynamically
        }

            ;

        // --- UI CLASS ---
        class GameUI {
            constructor(game) {
                this.game = game;
                this.app = document.getElementById('app');
                this.sortingArea = document.getElementById('sorting-area');
                this.tableauArea = document.getElementById('tableau-area');
                this.graveyard = document.getElementById('graveyard'); // Open Pile
                this.deckPile = document.getElementById('deck-pile'); // Hidden Draw Pile
                this.turnsValue = document.getElementById('turns-value');
            }

            init() {
                this.renderLayout();
                this.setupDifficultyUI();
            }

            setupDifficultyUI() {
                const buttons = document.querySelectorAll('.diff-btn');

                buttons.forEach(btn => {
                    btn.onclick = () => {
                        // Prevent accidental click if already active (Optional, but good UX)
                        if (btn.classList.contains('active')) return;

                        if (confirm("ÎÇúÏù¥ÎèÑÎ•º Î≥ÄÍ≤ΩÌïòÏãúÍ≤†ÏäµÎãàÍπå?\n(Í≤åÏûÑÏù¥ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§)")) {
                            // Update UI
                            buttons.forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            // Update Game Config and Restart
                            this.game.setDifficulty(btn.dataset.diff);
                        }
                    }

                        ;
                });
            }

            renderLayout() {
                // Sorting Slots - FIXED at 4
                this.sortingArea.innerHTML = '';

                // We create 4 empty slots regardless of category count
                for (let i = 0; i < 4; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'slot sorting-slot';
                    slot.dataset.index = i;
                    this.makeDroppable(slot, 'sorting', i);
                    this.sortingArea.appendChild(slot);
                }

                // Tableau Columns - Remains 4
                this.tableauArea.innerHTML = '';

                for (let i = 0; i < 4; i++) {
                    const col = document.createElement('div');
                    col.className = 'tableau-column';
                    col.dataset.index = i;

                    // FIX: Make the column itself the drop target (since base might be hidden or cards absolute)
                    this.makeDroppable(col, 'tableau', i);

                    const base = document.createElement('div');
                    base.className = 'slot-base';
                    // base is hidden by CSS, so attaching here is useless for mouse events if display:none
                    // But we keep it structure-wise if needed later.

                    col.appendChild(base);
                    this.tableauArea.appendChild(col);
                }

                // Deck Loop Click
                this.deckPile.onclick = () => this.game.drawCard();

                // Restart Button
                document.getElementById('restart-btn').onclick = () => this.game.restart();
            }

            update(state) {
                this.turnsValue.textContent = state.turnsLeft;

                // Sync Difficulty UI
                const diffButtons = document.querySelectorAll('.diff-btn');

                diffButtons.forEach(btn => {
                    if (btn.dataset.diff === this.game.difficulty) {
                        btn.classList.add('active');
                    }

                    else {
                        btn.classList.remove('active');
                    }
                });

                // 1. Sorting Slots
                state.sortingSlots.forEach((pile, i) => {
                    const slot = this.sortingArea.children[i];

                    // Update Label based on content
                    if (pile.length > 0) {
                        const keyCard = pile[0];
                        // Look up current game category config
                        const catConfig = this.game.activeCategories[keyCard.category];

                        // Calculate counters
                        const total = catConfig.itemCount; // Dynamically set item count
                        const current = pile.length - 1; // Subtract Key Card

                        // Format: Category (Newline) (Total/Collected)
                        // Format: Category (Newline) (Total/Collected)
                        slot.setAttribute('data-label', `${catConfig.label}\n(${total}/${current})`);
                    }

                    else {
                        slot.removeAttribute('data-label');
                    }

                    // Clean
                    const oldCards = slot.querySelectorAll('.card');
                    oldCards.forEach(c => c.remove());

                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        const cardEl = this.createCardElement(topCard);
                        cardEl.dataset.sourceType = 'sorting';
                        cardEl.dataset.sourceIndex = i;
                        slot.appendChild(cardEl);
                    }
                });

                // 2. Tableau
                const cols = document.querySelectorAll('.tableau-column');

                // Calculate measures for dynamic spacing
                const tableauHeight = this.tableauArea.clientHeight;
                // Approx card height (width / 4 * 1.4 ratio from CSS) or just use a safe fixed value typical for mobile
                // Let's rely on a robust estimation: 
                const cardHeightPx = this.tableauArea.clientWidth / 4 * 1.4;
                const maxColumnH = Math.max(tableauHeight, 400); // Ensure at least 400px base space

                cols.forEach((col, i) => {
                    const pile = state.tableauSlots[i];
                    const cards = col.querySelectorAll('.card');
                    cards.forEach(c => c.remove());

                    // Dynamic Spacing Calculation
                    let spacing = 35; // Default standard spacing
                    if (pile.length > 1) {
                        // How much space do we need at default spacing?
                        const totalNeeded = (pile.length - 1) * spacing + cardHeightPx;

                        // Available space in the column container? 
                        // The container stretches, but we want to fit in the VIEW.
                        // Let's use the tableauArea height as the constraint.
                        if (totalNeeded > maxColumnH) {
                            // Squeeze: (Available - CardHeight) / (Count - 1)
                            spacing = (maxColumnH - cardHeightPx - 20) / (pile.length - 1);
                            spacing = Math.max(15, spacing); // Hard floor
                        }
                    }

                    pile.forEach((card, cardIndex) => {
                        const isLast = cardIndex === pile.length - 1;
                        let cardEl;
                        const isFaceUp = card.faceUp === true;

                        if (isFaceUp) {
                            cardEl = this.createCardElement(card);
                            cardEl.draggable = true;

                            // Stacked view for covered cards
                            if (!isLast && card.type !== 'KEY') {
                                cardEl.classList.add('stacked-view');
                            }

                            // Dynamic Font Scaling if squished
                            if (spacing < 28) {
                                const label = cardEl.querySelector('.label');
                                if (label) {
                                    // Scale linear from 28px(100%) down to 15px(small)
                                    // 28 -> 100%, 15 -> 70%
                                    const scale = 0.7 + (0.3 * (spacing - 15) / 13);
                                    label.style.fontSize = `${Math.max(0.6, scale)}em`;

                                    // If really tight, hide emoji/extra padding if possible?
                                    if (spacing < 20) {
                                        cardEl.style.paddingTop = '2px';
                                    }
                                }
                            }
                        } else {
                            cardEl = document.createElement('div');
                            cardEl.className = 'card back';
                            const rabbit = document.createElement('div');
                            rabbit.className = 'rabbit-icon';
                            cardEl.appendChild(rabbit);
                            cardEl.draggable = false;
                        }

                        cardEl.style.top = `${cardIndex * spacing}px`;
                        cardEl.style.zIndex = cardIndex + 1;

                        cardEl.dataset.sourceType = 'tableau';
                        cardEl.dataset.sourceIndex = i;
                        cardEl.dataset.cardIndex = cardIndex;

                        if (!isLast) {
                            cardEl.style.cursor = 'default';
                        }

                        this.makeDroppable(cardEl, 'tableau', i);
                        col.appendChild(cardEl);
                    });
                });

                // 3. Open Pile (Graveyard/Discard)
                const openCards = this.graveyard.querySelectorAll('.card');
                openCards.forEach(c => c.remove());

                if (state.openPile.length > 0) {
                    const topCard = state.openPile[state.openPile.length - 1];
                    const cardEl = this.createCardElement(topCard);
                    cardEl.draggable = true;
                    cardEl.dataset.sourceType = 'graveyard';
                    this.graveyard.appendChild(cardEl);
                }

                // 4. Draw Pile (Deck) - Visual Thickness
                this.renderDeckThickness(state.deck.length);
            }

            renderDeckThickness(count) {
                this.deckPile.innerHTML = '';

                if (count > 0) {
                    const backCard = document.createElement('div');
                    backCard.className = 'card back';

                    const thickness = Math.min(Math.floor(count / 2), 10);

                    const shadow = Array.from({ length: thickness }, (_, i) => `${i + 1}px ${i + 1}px 0 #8d6e63`).join(', ');

                    backCard.style.boxShadow = shadow || 'none';

                    const rabbit = document.createElement('div');
                    rabbit.className = 'rabbit-icon';
                    backCard.appendChild(rabbit);

                    this.deckPile.appendChild(backCard);
                }

                else {
                    this.deckPile.innerHTML = '<div style="opacity:0.3; color:white;">EMPTY</div>';
                }
            }

            createCardElement(card) {
                const el = document.createElement('div');
                const typeClass = card.type === 'KEY' ? 'key-card' : 'sub-card';

                el.className = `card ${typeClass}`;
                el.draggable = true;
                el.dataset.id = card.id;

                // Content
                const label = document.createElement('span');
                label.className = 'label';
                label.style.fontSize = '14px'; // Smaller font for stack visibility
                label.style.lineHeight = '1.2';

                // Image Mode Support: Use Emoji if enabled for this category
                // EXCEPTION: Key Cards always show Text
                const catConfig = this.game.activeCategories[card.category];

                if (catConfig && catConfig.isImageMode && card.emoji && card.type !== 'KEY') {
                    label.textContent = card.emoji;
                    label.style.fontSize = 'var(--card-emoji-size)'; // Use CSS variable
                }

                else {
                    label.textContent = card.label;
                    label.style.fontSize = ''; // Reset to inherit from .card
                }

                el.appendChild(label);

                // Add Counter for Key Card
                if (card.type === 'KEY') {
                    // Calculate count
                    const catId = card.category;
                    const collected = this.game.getCollectedCount(catId);
                    const total = catConfig ? catConfig.itemCount : 8;

                    const counter = document.createElement('div');
                    counter.className = 'key-counter';

                    counter.textContent = `${total} / ${collected}`;
                    el.appendChild(counter);
                }

                el.addEventListener('dragstart', (e) => this.handleDragStart(e, card));

                // Touch Events for Mobile
                el.addEventListener('touchstart', (e) => this.handleTouchStart(e, card), {
                    passive: false
                });

                el.addEventListener('touchmove', (e) => this.handleTouchMove(e), {
                    passive: false
                });
                el.addEventListener('touchend', (e) => this.handleTouchEnd(e, card));

                // Double Click to Auto-Move Key Card
                el.addEventListener('dblclick', (e) => {
                    e.preventDefault();

                    if (card.type === 'KEY') {
                        this.game.tryAutoMoveKeyCard(card.id);
                    }
                });

                return el;
            }

            makeDroppable(el, type, index = -1) {
                el.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (el.classList.contains('slot')) el.style.backgroundColor = 'rgba(255,255,255,0.1)';
                });

                el.addEventListener('dragleave', (e) => {
                    if (el.classList.contains('slot')) el.style.backgroundColor = '';
                });

                el.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (el.classList.contains('slot')) el.style.backgroundColor = '';
                    const cardId = e.dataTransfer.getData('text/plain');
                    this.game.handleDrop(cardId, type, index);
                });
            }

            handleDragStart(e, card) {
                e.dataTransfer.setData('text/plain', card.id);
                e.dataTransfer.effectAllowed = 'move';
            }

            // --- TOUCH SUPPORT ---
            handleTouchStart(e, card) {
                e.preventDefault(); // Stop scrolling
                const touch = e.touches[0];

                // Create Ghost
                this.dragGhost = document.createElement('div');
                this.dragGhost.className = e.target.className;
                this.dragGhost.innerHTML = e.target.innerHTML;
                this.dragGhost.style.position = 'fixed';
                this.dragGhost.style.width = getComputedStyle(e.target).width;
                this.dragGhost.style.height = getComputedStyle(e.target).height;

                this.dragGhost.style.left = `${touch.clientX - 30}px`;
                this.dragGhost.style.top = `${touch.clientY - 40}px`;
                this.dragGhost.style.opacity = '0.9';
                this.dragGhost.style.zIndex = '1000';
                this.dragGhost.style.pointerEvents = 'none'; // click-through
                this.dragGhost.style.transform = 'scale(1.1)';

                document.body.appendChild(this.dragGhost);

                // Store data
                this.touchDragCardId = card.id;
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (!this.dragGhost) return;
                const touch = e.touches[0];

                this.dragGhost.style.left = `${touch.clientX - 30}px`;
                this.dragGhost.style.top = `${touch.clientY - 40}px`;
            }

            handleTouchEnd(e, card) {
                if (this.dragGhost) {
                    this.dragGhost.remove();
                    this.dragGhost = null;
                }

                if (!this.touchDragCardId) return;

                const touch = e.changedTouches[0];
                // Find drop target (we need to hide the ghost first? we did remove it above)
                // We need to find the element *under* the finger

                // Hide any potential overlay temporarily if needed (ghost is already removed)
                const droppedEl = document.elementFromPoint(touch.clientX, touch.clientY);

                if (droppedEl) {
                    // Traverse up to find a droppable zone or styled card
                    // Added .tableau-column to the selector
                    let target = droppedEl.closest('.slot, .slot-base, .tableau-column, .card');

                    if (target) {
                        // 1. Dropped on a Card (Tableau or Sorting)
                        if (target.classList.contains('card')) {
                            // If tableau card, get index
                            if (target.dataset.sourceType === 'tableau') {
                                this.game.handleDrop(this.touchDragCardId, 'tableau', parseInt(target.dataset.sourceIndex));
                            }
                            // If sorting card (implicit), bubble to slot?
                            // Actually closest('.card') stops traversal.
                            // If it's in sorting, we need to find the parent slot.
                            else if (target.closest('.sorting-slot')) {
                                const slot = target.closest('.sorting-slot');
                                this.game.handleDrop(this.touchDragCardId, 'sorting', parseInt(slot.dataset.index));
                            }
                        }

                        // 2. Dropped on Tableau Column (Empty or Background)
                        else if (target.classList.contains('tableau-column')) {
                            this.game.handleDrop(this.touchDragCardId, 'tableau', parseInt(target.dataset.index));
                        }

                        // 3. Dropped on Sorting Slot (Empty)
                        else if (target.classList.contains('sorting-slot')) {
                            this.game.handleDrop(this.touchDragCardId, 'sorting', parseInt(target.dataset.index));
                        }
                    }
                }

                this.touchDragCardId = null;
            }
        }

        // --- GAME CLASS ---
        class Game {
            constructor() {

                // We don't init deck here, we do it in start() with randomization
                this.state = {
                    deck: [],
                    openPile: [],
                    sortingSlots: [[], [], [], []],
                    tableauSlots: [[], [], [], []],
                    turnsLeft: 0
                }

                    ;

                this.activeCategories = {}

                    ; // Stores the config for the current game
                this.ui = new GameUI(this);
                this.difficulty = 'NORMAL';
            }

            setDifficulty(diff) {
                this.difficulty = diff;
                this.setupGame(false);
                this.ui.update(this.state);
            }

            start() {
                this.setupGame(false); // First start: Normal (Default)
                this.ui.init();
                this.ui.update(this.state);
            }

            setupGame(randomizeDifficulty = false) {
                // Initialize difficulty logic
                const difficulties = ['EASY',
                    'NORMAL',
                    'HARD',
                    'EXTREME'];

                // If randomize requested OR difficulty is logicially missing/invalid, pick random
                if (randomizeDifficulty || !this.difficulty) {
                    this.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
                }



                // User Specified Formulas (Explicit Counts):
                // Easy: 5 cats, Heuristic * 1.3 (Generous)
                // Normal: 6 cats, Heuristic * 1.1 (Standard)
                // Hard: 7 cats, Heuristic * 0.9 (Requires Optimization)
                // Extreme: 8 cats, Heuristic * 0.75 (Perfect Play / Minimal Waste)

                let numCats = 4;
                let turnMultiplier = 1.5;

                switch (this.difficulty) {
                    case 'EASY':
                        numCats = 5;
                        turnMultiplier = 1.3;
                        break;
                    case 'NORMAL':
                        numCats = 6;
                        turnMultiplier = 1.0; // Slightly tighter
                        break;
                    case 'HARD':
                        numCats = 7;
                        turnMultiplier = 0.75; // Reduced from 0.8
                        break;
                    case 'EXTREME':
                        numCats = 8;
                        turnMultiplier = 0.42; // Reduced by 30% from 0.6
                        break;
                    default:
                        numCats = 6;
                        turnMultiplier = 1.0;
                }

                console.log(`[Game] Setup ${this.difficulty}: Cats=${numCats}, TurnMult=${turnMultiplier}`);

                // 1. Smart Category Selection (No Duplicates)
                const poolKeys = Object.keys(CATEGORIES_POOL);
                // Shuffle pool keys
                for (let i = poolKeys.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [poolKeys[i], poolKeys[j]] = [poolKeys[j], poolKeys[i]];
                }

                // Global used sets for this game session
                const usedItems = new Set();
                const usedEmojis = new Set();

                this.activeCategories = {};
                let totalCards = 0;
                let catsAdded = 0;

                for (const key of poolKeys) {
                    if (catsAdded >= numCats) break;

                    const template = CATEGORIES_POOL[key];
                    const validIndices = [];

                    // Filter items that clash with already used ones
                    template.items.forEach((item, idx) => {
                        const emoji = template.emojis ? template.emojis[idx] : null;

                        // Check strict duplication
                        if (!usedItems.has(item) && (!emoji || !usedEmojis.has(emoji))) {
                            validIndices.push(idx);
                        }
                    });

                    // If we have enough valid items (min 3)
                    if (validIndices.length >= 3) {
                        // Decide item count for this category (Random 3 to 8, but capped by valid count)
                        let targetCount = 3 + Math.floor(Math.random() * 6);
                        targetCount = Math.min(targetCount, validIndices.length);

                        // Select subset of valid indices
                        // Shuffle validIndices first to pick random valid items
                        for (let i = validIndices.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [validIndices[i], validIndices[j]] = [validIndices[j], validIndices[i]];
                        }
                        const selectedIndices = validIndices.slice(0, targetCount);

                        // Build Active Data
                        const activeItems = selectedIndices.map(i => template.items[i]);
                        const activeEmojis = template.emojis ? selectedIndices.map(i => template.emojis[i]) : [];

                        // Register used
                        activeItems.forEach(item => usedItems.add(item));
                        activeEmojis.forEach(emoji => { if (emoji) usedEmojis.add(emoji); });

                        // Image Mode Change (20%)
                        const isImageMode = Math.random() < 0.2;

                        this.activeCategories[key] = {
                            ...template,
                            itemCount: targetCount,
                            isImageMode: isImageMode,
                            activeItems: activeItems,
                            activeEmojis: activeEmojis
                        };

                        totalCards += (1 + targetCount);
                        catsAdded++;
                    }
                    // Else: Skip this category as it conflicts too much
                }

                if (catsAdded < numCats) {
                    console.warn(`[Setup] Could only find ${catsAdded} non-conflicting categories out of ${numCats} requested.`);
                }

                // 3. Initialize Deck (Create Card Objects)
                this.initializeDeck();
                // Note: Deck is created but not dealt. totalCards is accurate.

                // 4. Deal (MUST be done before Turn Calculation to know what's in Deck vs Tableau)
                this.dealInitialCards();

                // 5. Calculate Turns using Heuristic (Cycle Prediction)
                const heuristicTurns = this.calculateHeuristicTurns();

                console.log(`[Heuristic] Calculated Turns: $ {
                        heuristicTurns
                    }

                    `);

                // Difficulty Multiplier Application (User Request: Min * Multiplier)
                this.state.turnsLeft = Math.ceil(heuristicTurns * turnMultiplier);
            }

            calculateHeuristicTurns() {

                // 1. Map Key Locations
                // Map<CategoryId, { location: 'tableau'|'deck', index: number, depth?: number }>
                const keyMap = {}

                    ;

                // Check Tableau
                this.state.tableauSlots.forEach((pile, colIdx) => {
                    pile.forEach((card, depth) => {
                        if (card.type === 'KEY') {
                            // Depth 0 = Bottom. But we access from Top? 
                            // Access difficulty is length-1 - depth.
                            // Actually, simply: If it's in Tableau, it's roughly "Cycle 1" accessible 
                            // but adds a penalty for digging.
                            const digCost = (pile.length - 1) - depth;

                            keyMap[card.category] = {
                                location: 'tableau', digCost: digCost
                            }

                                ;
                        }
                    });
                });

                // Check Deck
                // Deck is a stack. pop() gets the last element.
                // Draw Order: index K (length-1) is drawn 1st. Index 0 is drawn Last.
                // Let's analyze "Draw Index" where 0 = First Drawn.
                const deckSize = this.state.deck.length; // Remaining after deal

                this.state.deck.forEach((card, arrayIdx) => {
                    // arrayIdx 0 = Bottom. Draw Index = length - 1 - arrayIdx
                    const drawIndex = deckSize - 1 - arrayIdx;

                    if (card.type === 'KEY') {
                        keyMap[card.category] = {
                            location: 'deck', index: drawIndex
                        }

                            ;
                    }
                });

                // 2. Analyze Sub Cards
                let maxCycles = 1;

                this.state.deck.forEach((card, arrayIdx) => {
                    const drawIndex = deckSize - 1 - arrayIdx;

                    if (card.type === 'SUB') {
                        const keyInfo = keyMap[card.category];

                        // Scenario A: Key is in Tableau
                        // We can play this Sub in Cycle 1 (assuming we dug out the key).
                        // If Dig Cost is high, simpler heuristic adds fixed penalty later.

                        // Scenario B: Key is in Deck
                        if (keyInfo && keyInfo.location === 'deck') {

                            // If Sub appears BEFORE Key (DrawIndex < KeyIndex)
                            // Example: Sub at Draw 5, Key at Draw 20.
                            // We see Sub. Can't play. Discard.
                            // We find Key at 20. Play.
                            // We need to recycle to find Sub again. -> Cycle 2.
                            if (drawIndex < keyInfo.index) {
                                maxCycles = Math.max(maxCycles, 2);
                            }
                        }
                    }
                });

                // 3. Calculate Base Turns
                // Base = Cards in Deck * RequiresCycles
                // If Cycle 2 needed, we essentially draw the whole deck once (Missed Subs), 
                // then recycle, then draw again found Subs.
                // Accurate turn count = DeckSize + (MissedSubsCount * RecycleCost?)
                // Simple View: DeckSize * MaxCycles
                let baseTurns = deckSize * maxCycles;

                // 4. Add Penalties for Buried Keys
                let penalty = 0;

                Object.values(keyMap).forEach(info => {
                    if (info.location === 'tableau') {
                        // 2 turns per card covering the key
                        penalty += (info.digCost * 2);
                    }
                });

                return baseTurns + penalty;
            }

            initializeDeck() {
                let cards = [];

                Object.values(this.activeCategories).forEach(cat => {

                    // Key Card
                    cards.push({
                        id: `KEY_${cat.id}`,
                        type: CARD_TYPES.KEY,
                        category: cat.id,
                        label: cat.label,
                        emoji: 'üîë' // Key emoji? Or just label
                    });

                    // Sub Cards
                    cat.activeItems.forEach((item, idx) => {
                        cards.push({
                            id: `SUB_${cat.id}_${idx}`,
                            type: CARD_TYPES.SUB,
                            category: cat.id,
                            label: item,
                            emoji: cat.activeEmojis[idx] || item // Fallback
                        });
                    });
                });
                this.shuffle(cards);
                this.state.deck = cards;
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i],
                    array[j]] = [array[j],
                    array[i]];
                }
            }

            dealInitialCards() {
                this.state.tableauSlots = [[],
                [],
                [],
                []]; // Ensure clear

                const totalCards = this.state.deck.length;
                const dealCount = Math.floor(totalCards * 0.4); // 40%

                // Smart Mixing Configuration
                let allowClumping = 0.6; // Default Normal
                if (this.difficulty === 'EASY') allowClumping = 1.0;
                if (this.difficulty === 'NORMAL') allowClumping = 0.6;
                if (this.difficulty === 'HARD') allowClumping = 0.3;
                if (this.difficulty === 'EXTREME') allowClumping = 0.1;

                // Distribute cards round-robin with Smart Mixing
                for (let k = 0; k < dealCount; k++) {
                    if (this.state.deck.length > 0) {
                        const colIndex = k % 4;
                        const currentPile = this.state.tableauSlots[colIndex];

                        // Peek at what we are about to deal
                        let candidate = this.state.deck[this.state.deck.length - 1];

                        // Check previous card in this column
                        if (currentPile.length > 0) {
                            const prevCard = currentPile[currentPile.length - 1];

                            // If Same Category
                            if (prevCard.category === candidate.category) {

                                // Decide if we should avoid this
                                if (Math.random() > allowClumping) {
                                    // Try to find a better candidate in the deck
                                    // Search from second-to-last downwards
                                    let swapIndex = -1;

                                    for (let d = this.state.deck.length - 2; d >= 0; d--) {
                                        if (this.state.deck[d].category !== prevCard.category) {
                                            swapIndex = d;
                                            break;
                                        }
                                    }

                                    if (swapIndex !== -1) {
                                        // Swap found card to top
                                        const temp = this.state.deck[this.state.deck.length - 1];
                                        this.state.deck[this.state.deck.length - 1] = this.state.deck[swapIndex];
                                        this.state.deck[swapIndex] = temp;

                                        // Update candidate
                                        candidate = this.state.deck[this.state.deck.length - 1];
                                        // console.log(`[SmartMix] Swapped to avoid ${prevCard.category} clumping`);
                                    }
                                }
                            }
                        }

                        const card = this.state.deck.pop();
                        this.state.tableauSlots[colIndex].push(card);
                    }
                }

                // Set Face Up for the last card in each column
                this.state.tableauSlots.forEach(pile => {
                    if (pile.length > 0) {
                        // Reset all to face down first (default is undefined/false)
                        pile.forEach(c => c.faceUp = false);
                        // Set top to face up
                        pile[pile.length - 1].faceUp = true;
                    }
                });
            }

            restart() {
                if (confirm("Í≤åÏûÑÏùÑ Ïû¨ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå? (ÎÇúÏù¥ÎèÑÍ∞Ä Î¨¥ÏûëÏúÑÎ°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§)")) {
                    this.state = {
                        deck: [],
                        openPile: [],
                        sortingSlots: [[], [], [], []],
                        tableauSlots: [[], [], [], []],
                        turnsLeft: 0,
                        gameOver: false
                    }

                        ;
                    this.setupGame(true); // Restart = Random Difficulty
                    this.ui.update(this.state);
                }
            }

            drawCard() {
                if (this.state.turnsLeft <= 0) {
                    alert('ÎÇ®ÏùÄ ÌÑ¥Ïù¥ ÏóÜÏäµÎãàÎã§.');
                    return;
                }

                if (this.state.deck.length === 0) {
                    if (this.state.openPile.length > 0) {
                        // Recycle: Move openPile back to deck (reversed)
                        this.state.deck = [...this.state.openPile].reverse();
                        this.state.openPile = [];
                        // Don't consume turn on recycle? Or do? 
                        // Standard Solitaire: Recycling prevents stalemate. Usually free or limited.
                        // User didn't specify cost, let's make it free action but consume turn on Draw.
                        this.ui.update(this.state);
                        return;
                    }

                    else {
                        return; // Both empty
                    }
                }

                const card = this.state.deck.pop();
                this.state.openPile.push(card);
                this.state.turnsLeft--;

                this.ui.update(this.state);
            }

            findCardLocation(cardId) {
                const openIdx = this.state.openPile.findIndex(c => c.id === cardId);

                if (openIdx !== -1) return {
                    location: 'graveyard', index: -1, cardIndex: openIdx
                }

                    ;

                for (let i = 0; i < 4; i++) {
                    const idx = this.state.tableauSlots[i].findIndex(c => c.id === cardId);

                    if (idx !== -1) return {
                        location: 'tableau', index: i, cardIndex: idx
                    }

                        ;
                }

                for (let i = 0; i < 4; i++) {
                    const idx = this.state.sortingSlots[i].findIndex(c => c.id === cardId);

                    if (idx !== -1) return {
                        location: 'sorting', index: i, cardIndex: idx
                    }

                        ;
                }

                return null;
            }

            validateDrop(card, targetType, targetIndex) {
                if (targetType === 'sorting') {
                    const pile = this.state.sortingSlots[targetIndex];
                    const topCard = pile.length > 0 ? pile[pile.length - 1] : null;

                    if (!topCard) {
                        return card.type === CARD_TYPES.KEY;
                    }

                    else {
                        return card.type === CARD_TYPES.SUB && card.category === topCard.category;
                    }
                }

                if (targetType === 'tableau') {
                    const pile = this.state.tableauSlots[targetIndex];
                    if (pile.length === 0) return true;

                    const topCard = pile[pile.length - 1];

                    // Rule: Cannot place anything on a KEY card in Tableau
                    if (topCard.type === CARD_TYPES.KEY) {
                        return false;
                    }

                    // Otherwise, must match category
                    return card.category === topCard.category;
                }

                return false;
            }

            handleDrop(cardId, targetType, targetIndex) {
                const source = this.findCardLocation(cardId);
                if (!source) return;

                // BUG FIX: Prevent dropping onto self (which triggers reveal logic incorrectly)
                if (source.location === targetType && source.index === targetIndex) return;

                let pile = null;
                if (source.location === 'graveyard') pile = this.state.openPile;
                else if (source.location === 'tableau') pile = this.state.tableauSlots[source.index];
                else if (source.location === 'sorting') pile = this.state.sortingSlots[source.index];

                const card = pile[source.cardIndex];

                // Restriction: For Graveyard, only top card can be moved.
                // For Tableau, we allow group dragging (middle cards), so we don't return here.
                if (source.location === 'graveyard' && source.cardIndex !== pile.length - 1) return;

                if (this.validateDrop(card, targetType, targetIndex)) {
                    // Group Move: Take all cards from the grabbed index to the end
                    const cardsToMove = pile.splice(source.cardIndex);

                    // Update Source: If we moved from Tableau, reveal the new top card
                    if (source.location === 'tableau' && pile.length > 0) {
                        pile[pile.length - 1].faceUp = true;
                    }

                    // Essential: Ensure all moved cards are Face Up
                    cardsToMove.forEach(c => c.faceUp = true);

                    // Add to Target
                    if (targetType === 'sorting') {
                        this.state.sortingSlots[targetIndex].push(...cardsToMove);

                        // Check for Category Completion (Slot Recycling)
                        const currentPile = this.state.sortingSlots[targetIndex];

                        if (currentPile.length > 0) {
                            const keyCard = currentPile[0];
                            const config = this.activeCategories[keyCard.category];

                            // Key + All Items
                            if (currentPile.length === (config.itemCount + 1)) {
                                this.state.sortingSlots[targetIndex] = [];
                            }
                        }

                        this.checkWinCondition();
                    }

                    else if (targetType === 'tableau') {
                        this.state.tableauSlots[targetIndex].push(...cardsToMove);
                    }

                    this.ui.update(this.state);
                }
            }

            tryAutoMoveKeyCard(cardId) {
                // Find empty sorting slot
                let targetSlotIndex = -1;

                for (let i = 0; i < 4; i++) {
                    if (this.state.sortingSlots[i].length === 0) {
                        targetSlotIndex = i;
                        break;
                    }
                }

                if (targetSlotIndex !== -1) {
                    this.handleDrop(cardId, 'sorting', targetSlotIndex);
                }
            }

            getCollectedCount(catId) {
                const slotIndex = this.state.sortingSlots.findIndex(pile => {
                    if (pile.length > 0) return pile[0].category === catId;
                    return false;
                });

                if (slotIndex === -1) return 0;
                // Subtract 1 because first card is KEY
                return Math.max(0, this.state.sortingSlots[slotIndex].length - 1);
            }

            checkWinCondition() {
                const totalCards = this.state.deck.length + this.state.openPile.length + this.state.tableauSlots.flat().length;

                if (totalCards === 0) {
                    setTimeout(() => alert("Ï∂ïÌïòÌï©ÎãàÎã§! Î™®Îì† Ïπ¥ÎìúÎ•º Ï†ïÎ¶¨ÌñàÏäµÎãàÎã§!"), 100);
                }
            }
        }

        const game = new Game();
        game.start();
        window.game = game;
    </script>
</body>

</html>