<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÜîÎ¶¨ÌÖåÏñ¥</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --text-color: #ffffff;
            --card-width: 100px;
            --card-height: 140px;
            --gap: 16px;
            --primary-font: 'Noto Sans KR', sans-serif;
            --card-radius: 12px;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-border-subtle: rgba(255, 255, 255, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--primary-font);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* 
           Layout Strategy: 
           3-Column Grid: [Left: Turn] [Center: Game Board] [Right: Deck]
           This ensures the Game Board (Sorting + Tableau) is isolated and aligned perfectly.
        */
        #app {
            display: grid;
            grid-template-columns: 140px auto 260px;
            gap: 40px;
            padding: 24px;
            max-width: 1400px;
            width: 100%;
            height: 90vh;
            align-items: start;
        }

        /* LEFT PANEL */
        .left-panel {
            display: flex;
            justify-content: flex-start;
            padding-top: 30px;
            /* Visual alignment with top slots */
        }

        .turn-counter {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: var(--card-width);
            height: var(--card-height);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-subtle);
            border-radius: var(--card-radius);
            backdrop-filter: blur(10px);
        }

        .turn-counter .label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .turn-counter .value {
            font-size: 2rem;
            font-weight: 800;
        }

        .restart-btn {
            width: var(--card-width);
            height: 40px;
            background: rgba(255, 82, 82, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--card-radius);
            color: white;
            font-family: var(--primary-font);
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 16px;
            /* Space between button and counter */
            transition: background 0.2s;
        }

        .restart-btn:hover {
            background: rgba(255, 82, 82, 1);
        }

        /* CENTER BOARD */
        .center-board {
            display: flex;
            flex-direction: column;
            gap: 40px;
            /* Vertical gap between Sorting Area and Tableau Area */
            align-items: center;
            width: 100%;
        }

        /* 
           Crucial for Alignment:
           Both Sorting Area and Tableau Area use the SAME Grid configuration.
           This creates a "Room" of identical width and column positions.
        */
        .sorting-area,
        .tableau-area {
            display: grid;
            grid-template-columns: repeat(4, var(--card-width));
            gap: var(--gap);
            justify-content: center;
            width: 100%;
        }

        /* Tableau area needs height for the columns to expand downwards */
        .tableau-area {
            min-height: 400px;
            align-items: start;
        }

        /* RIGHT PANEL */
        .right-panel {
            display: flex;
            justify-content: flex-end;
            padding-top: 30px;
        }

        .deck-area {
            display: flex;
            gap: var(--gap);
        }

        /* SLOTS & COLUMNS */
        .slot {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px dashed var(--glass-border-subtle);
            border-radius: var(--card-radius);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .sorting-slot::before {
            content: attr(data-label);
            position: absolute;
            top: -50px;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-color);
            white-space: pre;
            line-height: 1.4;
        }

        .tableau-column {
            display: flex;
            flex-direction: column;
            width: var(--card-width);
            position: relative;
        }

        .slot-base {
            width: 100%;
            height: var(--card-height);
            border-radius: var(--card-radius);
            background: rgba(0, 0, 0, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            /* Brighter Dashed Border */
        }

        /* --- CARD STYLING --- */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--card-radius);
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            cursor: grab;
            position: absolute;
            transition: top 0.2s ease, transform 0.2s ease;

            display: flex;
            flex-direction: column;
            justify-content: center;
            /* Default: Center aligned */
            align-items: center;
            text-align: center;
            font-weight: 700;
            font-size: 1rem;
            padding-top: 10px;
            /* Space for label visibility */

            background-color: white;
            z-index: 10;
        }

        .card.key-card {
            background-color: #ffffff;
            border: 3px solid #ff5252;
            color: #d32f2f;
            font-weight: 900;
            font-weight: 900;
            justify-content: space-between;
            padding-top: 15px;
            /* Keep specific padding for Key Card */
            padding-bottom: 5px;
        }

        /* Key Card Counter */
        .key-counter {
            font-size: 0.8rem;
            color: #d32f2f;
            opacity: 0.8;
            margin-top: 5px;
        }

        .card.sub-card {
            background-color: #ffffff;
            border: 2px solid #448aff;
            color: #333;
        }

        /* When a card is stacked under another (Tableau), align to top to show label */
        .card.stacked-view {
            justify-content: flex-start !important;
            padding-top: 8px;
        }

        .card:active {
            cursor: grabbing;
            transform: scale(1.05);
            z-index: 100 !important;
        }

        .card.back {
            background-color: #E0D7D0;
            border: 2px solid #BCAAA4;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        /* Improved Rabbit Icon */
        .card.back .rabbit-icon {
            width: 60%;
            height: 60%;
            background-color: #3e2723;
            -webkit-mask: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12,2C12,2 8,5 8,10C8,11.5 8.5,13 9,14C7,14 4,16 4,19C4,21 6,22 12,22C18,22 20,21 20,19C20,16 17,14 15,14C15.5,13 16,11.5 16,10C16,5 12,2 12,2M12,5C12.8,5 13.5,7 13.8,9C13.2,8.8 12.6,8.8 12,8.8C11.4,8.8 10.8,8.8 10.2,9C10.5,7 11.2,5 12,5Z"/></svg>') no-repeat center;
            -webkit-mask-size: contain;
            mask: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12,2C12,2 8,5 8,10C8,11.5 8.5,13 9,14C7,14 4,16 4,19C4,21 6,22 12,22C18,22 20,21 20,19C20,16 17,14 15,14C15.5,13 16,11.5 16,10C16,5 12,2 12,2M12,5C12.8,5 13.5,7 13.8,9C13.2,8.8 12.6,8.8 12,8.8C11.4,8.8 10.8,8.8 10.2,9C10.5,7 11.2,5 12,5Z"/></svg>') no-repeat center;
            mask-size: contain;
        }

        .card.back span.label {
            display: none;
        }

        /* --- DIFFICULTY UI --- */
        .difficulty-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .diff-btn {
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.75rem;
            cursor: pointer;
            color: white;
            opacity: 0.6;
            transition: all 0.2s;
            font-weight: bold;
        }

        .diff-btn.active {
            opacity: 1;
            transform: scale(1.05);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .diff-easy {
            background-color: #4CAF50;
        }

        /* Green */
        .diff-normal {
            background-color: #2196F3;
        }

        /* Blue */
        .diff-hard {
            background-color: #FF9800;
        }

        /* Orange */
        .diff-extreme {
            background-color: #E91E63;
        }

        /* Pink */

        /* --- MOBILE RESPONSIVE --- */

        /* 1. PORTRAIT (Vertical Layout) - Optimized for One Hand / Long View */
        @media (max-width: 768px) and (orientation: portrait) {
            :root {
                /* Use vmin to ensure it fits width */
                --card-width: 20vw;
                --card-height: 28vw;
                /* Ratio 1.4 */
                --gap: 2vw;
                --card-radius: 4px;
            }

            #app {
                display: flex;
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                /* Dynamic Viewport Height for mobile browsers */
                padding: 10px 5px;
                gap: 10px;
                overflow: hidden;
                /* Prevent body scroll, handle inside tableau */
                box-sizing: border-box;
            }

            /* TOP: Control Bar (Turns, Restart) */
            .left-panel {
                width: 100%;
                height: 40px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 0 10px;
                order: 1;
                flex: none;
            }

            .left-panel>div {
                flex-direction: row !important;
                width: auto;
                gap: 10px;
            }

            .turn-counter {
                height: auto;
                padding: 5px 10px;
                flex-direction: row;
            }

            .restart-btn {
                margin: 0;
                padding: 5px 10px;
                width: auto;
                font-size: 0.8rem;
            }

            /* MIDDLE: Board */
            .center-board {
                width: 100%;
                order: 2;
                flex: 1;
                /* Take remaining space */
                gap: 10px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                /* Contain inner scroll */
            }

            .sorting-area {
                /* Top of Board */
                grid-template-columns: repeat(4, var(--card-width));
                gap: var(--gap);
                padding-bottom: 5px;
                flex: none;
                /* Fixed height */
                justify-content: center;
            }

            .tableau-area {
                /* Main Area */
                grid-template-columns: repeat(4, var(--card-width));
                gap: var(--gap);
                flex: 1;
                overflow-y: auto;
                /* Scroll ONLY the tableau columns if needed */
                min-height: 0;
                justify-content: center;
                padding-top: 10px;
            }

            /* Remove Bases visual noise in compact mode */
            .slot-base {
                border-color: rgba(255, 255, 255, 0.1);
            }

            /* BOTTOM: Deck & Grave */
            .right-panel {
                order: 3;
                width: 100%;
                height: 90px;
                /* Fixed height for touch target */
                flex-direction: row;
                justify-content: center;
                align-items: center;
                gap: 30px;
                padding: 0;
                flex: none;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 12px;
            }

            /* Adjust Fonts */
            .card {
                font-size: 0.75rem;
                padding: 2px;
                border-width: 1px;
            }

            .label {
                font-size: 0.7rem !important;
            }

            .key-counter {
                font-size: 0.6rem;
                bottom: 2px;
                right: 2px;
            }

            .sorting-slot::before {
                display: none;
            }

            /* Hide helper text on mobile to save space */
        }

        /* 2. LANDSCAPE (Horizontal Layout) - Scaled Down Desktop View */
        @media (max-width: 900px) and (orientation: landscape) {
            :root {
                /* Smaller fixed size for landscape mobile */
                --card-width: 60px;
                --card-height: 84px;
                --gap: 8px;
            }

            #app {
                display: grid;
                grid-template-columns: 80px 1fr 100px;
                /* Compact columns */
                height: 100vh;
                height: 100dvh;
                padding: 5px;
                gap: 5px;
                overflow: hidden;
            }

            /* Left: Controls */
            .left-panel {
                order: 1;
                padding: 0;
                justify-content: center;
            }

            .turn-counter {
                width: 100%;
                padding: 5px;
                font-size: 0.8rem;
            }

            .restart-btn {
                width: 100%;
                margin-top: 10px;
                padding: 5px;
                font-size: 0.8rem;
            }

            /* Center: Board */
            .center-board {
                order: 2;
                gap: 5px;
            }

            .sorting-area,
            .tableau-area {
                grid-template-columns: repeat(4, var(--card-width));
                gap: var(--gap);
                justify-content: center;
            }

            .tableau-area {
                padding-top: 10px;
                overflow-y: auto;
            }

            /* Right: Deck */
            .right-panel {
                order: 3;
                padding: 10px 0;
                gap: 15px;
            }

            .card {
                font-size: 0.7rem;
            }

            .label {
                font-size: 0.65rem !important;
            }

            .sorting-slot::before {
                opacity: 0.5;
                font-size: 0.6rem;
                top: -15px;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- 1. LEFT PANEL: Turn Counter -->
        <div class="left-panel">
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <!-- Difficulty Selector -->
                <div class="difficulty-selector" id="diff-selector">
                    <button class="diff-btn diff-easy" data-diff="EASY">Ïâ¨ÏõÄ</button>
                    <button class="diff-btn diff-normal active" data-diff="NORMAL">Î≥¥ÌÜµ</button>
                    <button class="diff-btn diff-hard" data-diff="HARD">Ïñ¥Î†§ÏõÄ</button>
                    <button class="diff-btn diff-extreme" data-diff="EXTREME">Í∑πÏïÖ</button>
                </div>

                <div style="display: flex; flex-direction: row; gap: 10px; align-items: center;">
                    <button id="restart-btn" class="restart-btn">Ïû¨ÏãúÏûë</button>
                    <div class="turn-counter">
                        <span class="label">ÎÇ®ÏùÄ ÌÑ¥</span>
                        <span id="turns-value" class="value">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 2. CENTER BOARD: Sorting & Tableau -->
        <div class="center-board">
            <!-- Row 1: Sorting Slots -->
            <div id="sorting-area" class="sorting-area">
                <!-- Sorting Slots generated by JS -->
            </div>

            <!-- Row 2: Tableau Columns -->
            <div id="tableau-area" class="tableau-area">
                <!-- Deployment Slots -->
            </div>
        </div>

        <!-- 3. RIGHT PANEL: Deck & Graveyard -->
        <div class="right-panel">
            <div class="deck-area">
                <!-- Discard Pile (Open) -->
                <div id="graveyard" class="slot" style="border-style: solid; border-color: rgba(255,255,255,0.1);">
                    <!-- Face Up Cards go here -->
                </div>

                <!-- Draw Pile (Hidden) -->
                <div id="deck-pile" class="slot" style="border: none;">
                    <!-- Face Down Cards go here -->
                </div>
            </div>
        </div>
    </div>

    <script src="js/categories.js"></script>
    <script>
        // --- CONSTANTS ---
        // CATEGORIES_POOL is now loaded from js/categories.js

        const CARD_TYPES = {
            KEY: 'KEY',
            SUB: 'SUB'
        };

        const GAME_CONFIG = {
            // Turns will be calculated dynamically
        };

        // --- UI CLASS ---
        class GameUI {
            constructor(game) {
                this.game = game;
                this.app = document.getElementById('app');
                this.sortingArea = document.getElementById('sorting-area');
                this.tableauArea = document.getElementById('tableau-area');
                this.graveyard = document.getElementById('graveyard'); // Open Pile
                this.deckPile = document.getElementById('deck-pile'); // Hidden Draw Pile
                this.turnsValue = document.getElementById('turns-value');
            }

            init() {
                this.renderLayout();
                this.setupDifficultyUI();
            }

            setupDifficultyUI() {
                const buttons = document.querySelectorAll('.diff-btn');
                buttons.forEach(btn => {
                    btn.onclick = () => {
                        // Update UI
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // Update Game Config and Restart
                        this.game.setDifficulty(btn.dataset.diff);
                    };
                });
            }

            renderLayout() {
                // Sorting Slots - FIXED at 4
                this.sortingArea.innerHTML = '';
                // We create 4 empty slots regardless of category count
                for (let i = 0; i < 4; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'slot sorting-slot';
                    slot.dataset.index = i;
                    this.makeDroppable(slot, 'sorting', i);
                    this.sortingArea.appendChild(slot);
                }

                // Tableau Columns - Remains 4
                this.tableauArea.innerHTML = '';
                for (let i = 0; i < 4; i++) {
                    const col = document.createElement('div');
                    col.className = 'tableau-column';
                    col.dataset.index = i;

                    const base = document.createElement('div');
                    base.className = 'slot-base';
                    this.makeDroppable(base, 'tableau', i);

                    col.appendChild(base);
                    this.tableauArea.appendChild(col);
                }

                // Deck Loop Click
                this.deckPile.onclick = () => this.game.drawCard();

                // Restart Button
                document.getElementById('restart-btn').onclick = () => this.game.restart();
            }

            update(state) {
                this.turnsValue.textContent = state.turnsLeft;

                // Sync Difficulty UI
                const diffButtons = document.querySelectorAll('.diff-btn');
                diffButtons.forEach(btn => {
                    if (btn.dataset.diff === this.game.difficulty) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                // 1. Sorting Slots
                state.sortingSlots.forEach((pile, i) => {
                    const slot = this.sortingArea.children[i];

                    // Update Label based on content
                    if (pile.length > 0) {
                        const keyCard = pile[0];
                        // Look up current game category config
                        const catConfig = this.game.activeCategories[keyCard.category];

                        // Calculate counters
                        const total = catConfig.itemCount; // Dynamically set item count
                        const current = pile.length - 1; // Subtract Key Card

                        // Format: Category (Newline) (Total/Collected)
                        slot.setAttribute('data-label', `${catConfig.label}\n(${total}/${current})`);
                    } else {
                        slot.removeAttribute('data-label');
                    }

                    // Clean
                    const oldCards = slot.querySelectorAll('.card');
                    oldCards.forEach(c => c.remove());

                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        const cardEl = this.createCardElement(topCard);
                        cardEl.dataset.sourceType = 'sorting';
                        cardEl.dataset.sourceIndex = i;
                        slot.appendChild(cardEl);
                    }
                });

                // 2. Tableau
                const cols = document.querySelectorAll('.tableau-column');
                cols.forEach((col, i) => {
                    const pile = state.tableauSlots[i];
                    const cards = col.querySelectorAll('.card');
                    cards.forEach(c => c.remove());

                    pile.forEach((card, cardIndex) => {
                        const isLast = cardIndex === pile.length - 1;
                        let cardEl;

                        // Use persistent faceUp state OR default to isLast if undefined (safe fallback)
                        const isFaceUp = card.faceUp === true;

                        if (isFaceUp) {
                            // Front Face
                            cardEl = this.createCardElement(card);
                            cardEl.draggable = true;

                            // If this card is NOT the last one (i.e. covered by others), align text to top
                            if (!isLast && card.type !== 'KEY') {
                                cardEl.classList.add('stacked-view');
                            }
                        } else {
                            // Back Face
                            cardEl = document.createElement('div');
                            cardEl.className = 'card back';

                            // Rabbit Icon for back
                            const rabbit = document.createElement('div');
                            rabbit.className = 'rabbit-icon';
                            cardEl.appendChild(rabbit);

                            cardEl.draggable = false;
                        }

                        cardEl.style.top = `${cardIndex * 35}px`;
                        cardEl.style.zIndex = cardIndex + 1;

                        cardEl.dataset.sourceType = 'tableau';
                        cardEl.dataset.sourceIndex = i;
                        cardEl.dataset.cardIndex = cardIndex;

                        if (!isLast) {
                            cardEl.style.cursor = 'default';
                        }

                        // FIX: Make the card itself droppable so we can stack on it
                        this.makeDroppable(cardEl, 'tableau', i);

                        col.appendChild(cardEl);
                    });
                });

                // 3. Open Pile (Graveyard/Discard)
                const openCards = this.graveyard.querySelectorAll('.card');
                openCards.forEach(c => c.remove());

                if (state.openPile.length > 0) {
                    const topCard = state.openPile[state.openPile.length - 1];
                    const cardEl = this.createCardElement(topCard);
                    cardEl.draggable = true;
                    cardEl.dataset.sourceType = 'graveyard';
                    this.graveyard.appendChild(cardEl);
                }

                // 4. Draw Pile (Deck) - Visual Thickness
                this.renderDeckThickness(state.deck.length);
            }

            renderDeckThickness(count) {
                this.deckPile.innerHTML = '';
                if (count > 0) {
                    const backCard = document.createElement('div');
                    backCard.className = 'card back';

                    const thickness = Math.min(Math.floor(count / 2), 10);
                    const shadow = Array.from({ length: thickness }, (_, i) =>
                        `${i + 1}px ${i + 1}px 0 #8d6e63`
                    ).join(', ');

                    backCard.style.boxShadow = shadow || 'none';

                    const rabbit = document.createElement('div');
                    rabbit.className = 'rabbit-icon';
                    backCard.appendChild(rabbit);

                    this.deckPile.appendChild(backCard);
                } else {
                    this.deckPile.innerHTML = '<div style="opacity:0.3; color:white;">EMPTY</div>';
                }
            }

            createCardElement(card) {
                const el = document.createElement('div');
                const typeClass = card.type === 'KEY' ? 'key-card' : 'sub-card';
                el.className = `card ${typeClass}`;
                el.draggable = true;
                el.dataset.id = card.id;

                // Content
                const label = document.createElement('span');
                label.className = 'label';
                label.style.fontSize = '14px'; // Smaller font for stack visibility
                label.style.lineHeight = '1.2';

                // Image Mode Support: Use Emoji if enabled for this category
                // EXCEPTION: Key Cards always show Text
                const catConfig = this.game.activeCategories[card.category];
                if (catConfig && catConfig.isImageMode && card.emoji && card.type !== 'KEY') {
                    label.textContent = card.emoji;
                    label.style.fontSize = '2rem'; // Larger for emoji
                } else {
                    label.textContent = card.label;
                }

                el.appendChild(label);

                // Add Counter for Key Card
                if (card.type === 'KEY') {
                    // Calculate count
                    const catId = card.category;
                    const collected = this.game.getCollectedCount(catId);
                    const total = catConfig ? catConfig.itemCount : 8;

                    const counter = document.createElement('div');
                    counter.className = 'key-counter';
                    counter.textContent = `${total} / ${collected}`;
                    el.appendChild(counter);
                }

                el.addEventListener('dragstart', (e) => this.handleDragStart(e, card));

                // Touch Events for Mobile
                el.addEventListener('touchstart', (e) => this.handleTouchStart(e, card), { passive: false });
                el.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                el.addEventListener('touchend', (e) => this.handleTouchEnd(e, card));

                return el;
            }

            makeDroppable(el, type, index = -1) {
                el.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (el.classList.contains('slot')) el.style.backgroundColor = 'rgba(255,255,255,0.1)';
                });

                el.addEventListener('dragleave', (e) => {
                    if (el.classList.contains('slot')) el.style.backgroundColor = '';
                });

                el.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (el.classList.contains('slot')) el.style.backgroundColor = '';
                    const cardId = e.dataTransfer.getData('text/plain');
                    this.game.handleDrop(cardId, type, index);
                });
            }

            handleDragStart(e, card) {
                e.dataTransfer.setData('text/plain', card.id);
                e.dataTransfer.effectAllowed = 'move';
            }

            // --- TOUCH SUPPORT ---
            handleTouchStart(e, card) {
                e.preventDefault(); // Stop scrolling
                const touch = e.touches[0];

                // Create Ghost
                this.dragGhost = document.createElement('div');
                this.dragGhost.className = e.target.className;
                this.dragGhost.innerHTML = e.target.innerHTML;
                this.dragGhost.style.position = 'fixed';
                this.dragGhost.style.width = getComputedStyle(e.target).width;
                this.dragGhost.style.height = getComputedStyle(e.target).height;
                this.dragGhost.style.left = `${touch.clientX - 30}px`;
                this.dragGhost.style.top = `${touch.clientY - 40}px`;
                this.dragGhost.style.opacity = '0.9';
                this.dragGhost.style.zIndex = '1000';
                this.dragGhost.style.pointerEvents = 'none'; // click-through
                this.dragGhost.style.transform = 'scale(1.1)';

                document.body.appendChild(this.dragGhost);

                // Store data
                this.touchDragCardId = card.id;
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (!this.dragGhost) return;
                const touch = e.touches[0];
                this.dragGhost.style.left = `${touch.clientX - 30}px`;
                this.dragGhost.style.top = `${touch.clientY - 40}px`;
            }

            handleTouchEnd(e, card) {
                if (this.dragGhost) {
                    this.dragGhost.remove();
                    this.dragGhost = null;
                }

                if (!this.touchDragCardId) return;

                const touch = e.changedTouches[0];
                // Find drop target (we need to hide the ghost first? we did remove it above)
                // We need to find the element *under* the finger

                // Hide any potential overlay temporarily if needed (ghost is already removed)
                const droppedEl = document.elementFromPoint(touch.clientX, touch.clientY);

                if (droppedEl) {
                    // Traverse up to find a droppable zone or styled card
                    // We need to identify if it's a Slot, Base, or Card in Tableau/Sorting

                    let target = droppedEl.closest('.slot, .slot-base, .tableau-column .card');

                    if (target) {
                        // Extract type and index from the closest significant element
                        // But wait, our 'makeDroppable' attached listeners to specific elements.
                        // We need to map the element back to 'type' and 'index'.

                        // If dropped on a card in tableau
                        if (target.classList.contains('card') && target.dataset.sourceType === 'tableau') {
                            const type = 'tableau';
                            const index = parseInt(target.dataset.sourceIndex);
                            this.game.handleDrop(this.touchDragCardId, type, index);
                        }
                        // If dropped on slot-base
                        else if (target.classList.contains('slot-base')) {
                            // Find parent column index?
                            // Actually makeDroppable passed index. We can store it in dataset for fallback.
                            // Our makeDroppable doesn't set dataset on base, but parent col has index.
                            const col = target.closest('.tableau-column');
                            if (col) {
                                this.game.handleDrop(this.touchDragCardId, 'tableau', parseInt(col.dataset.index));
                            }
                        }
                        // If dropped on sorting slot
                        else if (target.classList.contains('sorting-slot')) {
                            this.game.handleDrop(this.touchDragCardId, 'sorting', parseInt(target.dataset.index));
                        }
                    }
                }

                this.touchDragCardId = null;
            }
        }

        // --- GAME CLASS ---
        class Game {
            constructor() {
                // We don't init deck here, we do it in start() with randomization
                this.state = {
                    deck: [],
                    openPile: [],
                    sortingSlots: [[], [], [], []],
                    tableauSlots: [[], [], [], []],
                    turnsLeft: 0
                };
                this.activeCategories = {}; // Stores the config for the current game
                this.ui = new GameUI(this);
                this.difficulty = 'NORMAL';
            }

            setDifficulty(diff) {
                this.difficulty = diff;
                this.setupGame(false);
                this.ui.update(this.state);
            }

            start() {
                this.setupGame(false); // First start: Normal (Default)
                this.ui.init();
                this.ui.update(this.state);
            }

            setupGame(randomizeDifficulty = false) {
                // Initialize difficulty logic
                const difficulties = ['EASY', 'NORMAL', 'HARD', 'EXTREME'];

                // If randomize requested OR difficulty is logicially missing/invalid, pick random
                if (randomizeDifficulty || !this.difficulty) {
                    this.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
                }

                let catMultiplier = 1.5;
                let turnMultiplier = 2.0;

                // User Specified Formulas:
                // Category Count = Sorting Slots (4) * Percentage
                // Turns = Min Turns * Multiplier
                // Min Turns = Cards in Deck (Total - Tableau)
                switch (this.difficulty) {
                    case 'EASY':
                        catMultiplier = 1.3; // 4 * 1.3 = 5.2 -> 5
                        turnMultiplier = 2.0;
                        break;
                    case 'NORMAL':
                        catMultiplier = 1.3; // 4 * 1.3 = 5.2 -> 5
                        turnMultiplier = 1.5;
                        break;
                    case 'HARD':
                        catMultiplier = 1.5; // 4 * 1.5 = 6
                        turnMultiplier = 1.0;
                        break;
                    case 'EXTREME':
                        catMultiplier = 2.0; // 4 * 2.0 = 8
                        turnMultiplier = 1.0;
                        break;
                    default:
                        catMultiplier = 1.3;
                        turnMultiplier = 1.5;
                }

                // Fine adjustments removed as they are now integrated in logic

                const numCats = Math.floor(4 * catMultiplier);

                console.log(`[Game] Setup ${this.difficulty}: Cats=${numCats}, TurnMult=${turnMultiplier}`);

                // 1. Randomize Category Selection
                const poolKeys = Object.keys(CATEGORIES_POOL);

                // Shuffle pool keys
                for (let i = poolKeys.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [poolKeys[i], poolKeys[j]] = [poolKeys[j], poolKeys[i]];
                }

                const safeNumCats = Math.min(numCats, poolKeys.length);
                const selectedKeys = poolKeys.slice(0, safeNumCats);

                // 2. Setup Active Categories
                this.activeCategories = {};
                let totalCards = 0;

                selectedKeys.forEach(key => {
                    const template = CATEGORIES_POOL[key];

                    // Random Item Count (3 to 8)
                    let itemCount = 3 + Math.floor(Math.random() * 6);
                    itemCount = Math.min(itemCount, template.items.length);

                    // Image Mode Change (20%)
                    const isImageMode = Math.random() < 0.2;

                    this.activeCategories[key] = {
                        ...template,
                        itemCount: itemCount,
                        isImageMode: isImageMode,
                        activeItems: template.items.slice(0, itemCount),
                        activeEmojis: template.emojis ? template.emojis.slice(0, itemCount) : []
                    };
                    totalCards += (1 + itemCount); // 1 Key + Items
                });

                // 3. Initialize Deck (Create Card Objects)
                this.initializeDeck();
                // Note: Deck is created but not dealt. totalCards is accurate.

                // 4. Deal (Must deal BEFORE calc to set up initial state)
                this.dealInitialCards();

                // 5. Calculate Turns based on Perfect Play Simulation
                console.log("[Turn Calc] Starting Perfect Play Simulation...");
                const minTurns = this.calculateMinimumTurns();

                // Additive Buffer Calculation
                this.state.turnsLeft = minTurns + turnBuffer;

                console.log(`[Game] Setup ${this.difficulty}: Turns=${this.state.turnsLeft} (Sim ${minTurns} + ${turnBuffer})`);
            }

            initializeDeck() {
                let cards = [];
                Object.values(this.activeCategories).forEach(cat => {
                    // Key Card
                    cards.push({
                        id: `KEY_${cat.id}`,
                        type: CARD_TYPES.KEY,
                        category: cat.id,
                        label: cat.label,
                        emoji: 'üîë' // Key emoji? Or just label
                    });

                    // Sub Cards
                    cat.activeItems.forEach((item, idx) => {
                        cards.push({
                            id: `SUB_${cat.id}_${idx}`,
                            type: CARD_TYPES.SUB,
                            category: cat.id,
                            label: item,
                            emoji: cat.activeEmojis[idx] || item // Fallback
                        });
                    });
                });
                this.shuffle(cards);
                this.state.deck = cards;
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            dealInitialCards() {
                this.state.tableauSlots = [[], [], [], []]; // Ensure clear

                const totalCards = this.state.deck.length;
                const dealCount = Math.floor(totalCards * 0.4); // 40%

                // Distribute cards round-robin
                for (let k = 0; k < dealCount; k++) {
                    if (this.state.deck.length > 0) {
                        const card = this.state.deck.pop();
                        const colIndex = k % 4;
                        this.state.tableauSlots[colIndex].push(card);
                    }
                }

                // Set Face Up for the last card in each column
                this.state.tableauSlots.forEach(pile => {
                    if (pile.length > 0) {
                        // Reset all to face down first (default is undefined/false)
                        pile.forEach(c => c.faceUp = false);
                        // Set top to face up
                        pile[pile.length - 1].faceUp = true;
                    }
                });
            }

            // --- SIMULATION FOR DIFFICULTY CALCULATION ---
            calculateMinimumTurns() {
                // 1. Deep Clone State for Simulation
                // We need to simulate: Deck, Tableau, Sorting, OpenPile, Collected Keys
                let simDeck = JSON.parse(JSON.stringify(this.state.deck)); // Current Deck (after deal)
                let simTableau = JSON.parse(JSON.stringify(this.state.tableauSlots));
                let simSorting = [[], [], [], []]; // 4 Empty Sorting Slots
                let simOpenPile = [];
                let collectedKeys = new Set(); // Track enabled categories

                let turns = 0;
                let moves = 0;
                let maxcycles = 10; // Safety break
                let cycle = 0;

                // Helper: Check if card can go to Sorting
                const canSort = (card) => {
                    if (card.type === 'KEY') return true;
                    // Sub only if Key is active (in simulation, 'active' means Key is in simSorting or we track it)
                    // The game rule: Sorting Slot top card must be same category.
                    // Wait, game rule says: If slot empty, ONLY Key.
                    // If slot has card, ONLY Sub of same category.
                    // We need to track actual slots.

                    // Specific Logic:
                    // Find a slot that accepts this card.
                    // Case A: Key Card. Needs an empty slot.
                    if (card.type === 'KEY') {
                        return simSorting.some(slot => slot.length === 0);
                    }
                    // Case B: Sub Card. Needs a slot with matching Category.
                    if (card.type === 'SUB') {
                        return simSorting.some(slot => slot.length > 0 && slot[0].category === card.category);
                    }
                    return false;
                };

                const doSort = (card) => {
                    if (card.type === 'KEY') {
                        const emptyIdx = simSorting.findIndex(s => s.length === 0);
                        if (emptyIdx !== -1) simSorting[emptyIdx].push(card);
                    } else {
                        const matchIdx = simSorting.findIndex(s => s.length > 0 && s[0].category === card.category);
                        if (matchIdx !== -1) simSorting[matchIdx].push(card);
                    }
                    // Check Completion (Optional for sim, just keep sorting)
                    // In real game, completed slots empty. In sim, we can just keep stacking or clear.
                    // Clearing helps finding empty slots for NEW Keys.
                    // Check if pile is full (Key + Items).
                    simSorting.forEach((pile, idx) => {
                        if (pile.length > 0) {
                            const k = pile[0];
                            const config = this.activeCategories[k.category];
                            if (pile.length === (config.itemCount + 1)) {
                                simSorting[idx] = []; // Clear logic
                            }
                        }
                    });
                };

                // Simulation Loop
                while (cycle < maxcycles) {
                    let progressMade = false;

                    // Phase 1: Tableau Consoldiation & Auto-Play
                    // Continually check if any top card of Tableau can go to Sorting OR other Tableau
                    let tableuChanged = true;
                    while (tableuChanged) {
                        tableuChanged = false;

                        // 1a. Tableau -> Sorting
                        for (let i = 0; i < 4; i++) {
                            const col = simTableau[i];
                            if (col.length > 0) {
                                const top = col[col.length - 1];
                                if (canSort(top)) {
                                    doSort(col.pop());
                                    tableuChanged = true;
                                    progressMade = true;
                                    continue; // Restart loop to see if new top is sortable
                                }
                            }
                        }
                        if (tableuChanged) continue;

                        // 1b. Tableau -> Tableau (Consolidation)
                        // Move card from Col A to Col B if it helps (stacks matching category).
                        // This reduces waste significantly.
                        for (let i = 0; i < 4; i++) {
                            const sourceCol = simTableau[i];
                            if (sourceCol.length > 0) {
                                const card = sourceCol[sourceCol.length - 1];

                                // Try finding a target col with matching top
                                for (let j = 0; j < 4; j++) {
                                    if (i === j) continue;
                                    const targetCol = simTableau[j];

                                    if (targetCol.length > 0) {
                                        const targetTop = targetCol[targetCol.length - 1];
                                        if (targetTop.type !== 'KEY' && targetTop.category === card.category) {
                                            // Valid Merge!
                                            targetCol.push(sourceCol.pop());
                                            tableuChanged = true;
                                            progressMade = true;
                                            break; // Break inner, restart outer
                                        }
                                    }
                                }
                                if (tableuChanged) break;
                            }
                        }
                    }

                    // Check Win
                    const allTableauEmpty = simTableau.every(c => c.length === 0);
                    const deckEmpty = simDeck.length === 0 && simOpenPile.length === 0;
                    // Note: Sorting slots empty is win condition IF others empty.
                    // Simplified: If deck and tableau empty, we win.
                    if (allTableauEmpty && deckEmpty) {
                        break;
                    }

                    // Phase 2: Draw
                    if (simDeck.length === 0) {
                        if (simOpenPile.length > 0) {
                            // Recycle
                            simDeck = simOpenPile.reverse();
                            simOpenPile = [];
                            cycle++;
                            if (cycle >= maxcycles) break;
                        } else {
                            break; // Deadlock or Win
                        }
                    }

                    if (simDeck.length > 0) {
                        const card = simDeck.pop();
                        turns++;

                        // Logic:
                        // 1. Can Sort directly?
                        if (canSort(card)) {
                            doSort(card);
                            progressMade = true;
                        }
                        // 2. Can Slot in Tableau? (Optimize: Only if needed?)
                        // Perfect Play Strategy: Always keep Tableau slots full to dig deep?
                        // Or only hold if Key not ready?
                        // Simple Heuristic: If we can't sort, put in Tableau if possible.
                        // If Tableau full, put in OpenPile.
                        else {
                            // Try Tableau
                            // Priority: Empty Columns? or just any?
                            // Solitaire logic: Avoid blocking deep columns. But here columns are stacks.
                            // Just finding first available spot.
                            // BUT: Game rule usually restricts placing on Tableau?
                            // Valid Drop: "Cannot place on KEY", "Must match category".
                            // Wait, Real Game Rule: 'validateDrop' -> 'Target must match category'.
                            // This means we CANNOT just place any card in Tableau.
                            // We can only stack cards of SAME CATEGORY.
                            // And Empty Column accepts ANY card.

                            // Let's check Tableau placement rules for Simulation.
                            let placed = false;

                            // A. Try to stack on existing matching category
                            for (let i = 0; i < 4; i++) {
                                const col = simTableau[i];
                                if (col.length > 0) {
                                    const top = col[col.length - 1];
                                    if (top.type !== 'KEY' && top.category === card.category) {
                                        col.push(card);
                                        placed = true;
                                        break;
                                    }
                                }
                            }

                            // B. If not placed, Try Empty Column
                            if (!placed) {
                                const emptyColIdx = simTableau.findIndex(c => c.length === 0);
                                if (emptyColIdx !== -1) {
                                    simTableau[emptyColIdx].push(card);
                                    placed = true;
                                }
                            }

                            // C. Failed to Place -> Open Pile (Waste)
                            if (!placed) {
                                simOpenPile.push(card);
                            }
                        }
                    }
                }

                console.log(`[Simulation] Cycles: ${cycle}, Est Turns: ${turns}`);
                return turns > 0 ? turns : 50; // Safety fallback
            }

            restart() {
                if (confirm("Í≤åÏûÑÏùÑ Ïû¨ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå? (ÎÇúÏù¥ÎèÑÍ∞Ä Î¨¥ÏûëÏúÑÎ°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§)")) {
                    this.state = {
                        deck: [],
                        openPile: [],
                        sortingSlots: [[], [], [], []],
                        tableauSlots: [[], [], [], []],
                        turnsLeft: 0,
                        gameOver: false
                    };
                    this.setupGame(true); // Restart = Random Difficulty
                    this.ui.update(this.state);
                }
            }

            drawCard() {
                if (this.state.turnsLeft <= 0) {
                    alert('ÎÇ®ÏùÄ ÌÑ¥Ïù¥ ÏóÜÏäµÎãàÎã§.');
                    return;
                }

                if (this.state.deck.length === 0) {
                    if (this.state.openPile.length > 0) {
                        // Recycle: Move openPile back to deck (reversed)
                        this.state.deck = [...this.state.openPile].reverse();
                        this.state.openPile = [];
                        // Don't consume turn on recycle? Or do? 
                        // Standard Solitaire: Recycling prevents stalemate. Usually free or limited.
                        // User didn't specify cost, let's make it free action but consume turn on Draw.
                        this.ui.update(this.state);
                        return;
                    } else {
                        return; // Both empty
                    }
                }

                const card = this.state.deck.pop();
                this.state.openPile.push(card);
                this.state.turnsLeft--;

                this.ui.update(this.state);

                // Check for Game Over (failure) if turns ran out
                if (this.state.turnsLeft === 0) {
                    setTimeout(() => alert("ÌÑ¥Ïù¥ Î™®Îëê ÏÜåÏßÑÎêòÏóàÏäµÎãàÎã§. (Ïã§Ìå®)"), 100);
                }
            }

            findCardLocation(cardId) {
                const openIdx = this.state.openPile.findIndex(c => c.id === cardId);
                if (openIdx !== -1) return { location: 'graveyard', index: -1, cardIndex: openIdx };

                for (let i = 0; i < 4; i++) {
                    const idx = this.state.tableauSlots[i].findIndex(c => c.id === cardId);
                    if (idx !== -1) return { location: 'tableau', index: i, cardIndex: idx };
                }

                for (let i = 0; i < 4; i++) {
                    const idx = this.state.sortingSlots[i].findIndex(c => c.id === cardId);
                    if (idx !== -1) return { location: 'sorting', index: i, cardIndex: idx };
                }
                return null;
            }

            validateDrop(card, targetType, targetIndex) {
                if (targetType === 'sorting') {
                    const pile = this.state.sortingSlots[targetIndex];
                    const topCard = pile.length > 0 ? pile[pile.length - 1] : null;

                    if (!topCard) {
                        return card.type === CARD_TYPES.KEY;
                    } else {
                        return card.type === CARD_TYPES.SUB && card.category === topCard.category;
                    }
                }

                if (targetType === 'tableau') {
                    const pile = this.state.tableauSlots[targetIndex];
                    if (pile.length === 0) return true;

                    const topCard = pile[pile.length - 1];

                    // Rule: Cannot place anything on a KEY card in Tableau
                    if (topCard.type === CARD_TYPES.KEY) {
                        return false;
                    }

                    // Otherwise, must match category
                    return card.category === topCard.category;
                }
                return false;
            }

            handleDrop(cardId, targetType, targetIndex) {
                const source = this.findCardLocation(cardId);
                if (!source) return;

                let pile = null;
                if (source.location === 'graveyard') pile = this.state.openPile;
                else if (source.location === 'tableau') pile = this.state.tableauSlots[source.index];
                else if (source.location === 'sorting') pile = this.state.sortingSlots[source.index];

                const card = pile[source.cardIndex];

                // Restriction: For Graveyard, only top card can be moved.
                // For Tableau, we allow group dragging (middle cards), so we don't return here.
                if (source.location === 'graveyard' && source.cardIndex !== pile.length - 1) return;

                if (this.validateDrop(card, targetType, targetIndex)) {
                    // Group Move: Take all cards from the grabbed index to the end
                    const cardsToMove = pile.splice(source.cardIndex);

                    // Update Source: If we moved from Tableau, reveal the new top card
                    if (source.location === 'tableau' && pile.length > 0) {
                        pile[pile.length - 1].faceUp = true;
                    }

                    // Essential: Ensure all moved cards are Face Up
                    cardsToMove.forEach(c => c.faceUp = true);

                    // Add to Target
                    if (targetType === 'sorting') {
                        this.state.sortingSlots[targetIndex].push(...cardsToMove);

                        // Check for Category Completion (Slot Recycling)
                        const currentPile = this.state.sortingSlots[targetIndex];
                        if (currentPile.length > 0) {
                            const keyCard = currentPile[0];
                            const config = this.activeCategories[keyCard.category];

                            // Key + All Items
                            if (currentPile.length === (config.itemCount + 1)) {
                                // Delay slightly for visual effect then clear? Or just clear.
                                // For now, immediate clear with a small alert or just log.
                                // Reactivity: The update() will show empty slot.

                                // We can use setTimeout to let the user see the card land, 
                                // but state update is synchronous. 
                                // Let's just alert for now or trust the user sees the counter finish.

                                // Actually, clearing it immediately might feel abrupt. 
                                // But per rules: "Empty slot immediately".
                                this.state.sortingSlots[targetIndex] = [];
                                // Optional: You could add a 'completedCategories' count to state if shown in UI.
                            }
                        }

                        this.checkWinCondition();
                    } else if (targetType === 'tableau') {
                        this.state.tableauSlots[targetIndex].push(...cardsToMove);
                    }

                    this.ui.update(this.state);
                }
            }

            getCollectedCount(catId) {
                const slotIndex = this.state.sortingSlots.findIndex(pile => {
                    if (pile.length > 0) return pile[0].category === catId;
                    return false;
                });

                if (slotIndex === -1) return 0;
                // Subtract 1 because first card is KEY
                return Math.max(0, this.state.sortingSlots[slotIndex].length - 1);
            }

            checkWinCondition() {
                const totalCards = this.state.deck.length + this.state.openPile.length +
                    this.state.tableauSlots.flat().length;
                if (totalCards === 0) {
                    setTimeout(() => alert("Ï∂ïÌïòÌï©ÎãàÎã§! Î™®Îì† Ïπ¥ÎìúÎ•º Ï†ïÎ¶¨ÌñàÏäµÎãàÎã§!"), 100);
                }
            }
        }

        const game = new Game();
        game.start();
        window.game = game; 
    </script>
</body>

</html>